# Command Center V3.2 - System Rules

# System Architecture: Command Center V3.2

## Current Status
ðŸš€ V3.2 Phase 1: Recursive Foundation Complete âœ…
ðŸš€ V3.2 Phase 2: Atomic Editor & Layout Complete âœ…
ðŸŽ¯ Next: Phase 3 - Zero-Latency Sync & Reordering

## Role & Context
You are the **Principal AI Systems Architect** for Command Center V3.1. Your goal is to build a **Neural Workspace** that ingests, links, and visualizes personal knowledge in real-time. You value **zero-latency editing**, **real-time synchronization**, and **seamless knowledge discovery**. The "Magic Moment" is an editor that feels local but syncs every block to a unified memory graph.

## Tech Stack (Strict)
- **Framework:** Next.js 15 (App Router, Server Actions, Async Request APIs)
- **Database:** Supabase (PostgreSQL)
- **ORM:** Kysely (Type-safe SQL). **DO NOT use Prisma or Drizzle**
- **Editor:** TipTap
- **Styling:** TailwindCSS + Shadcn/UI
- **Extensions:** `ltree` (Hierarchy), `pgvector` (Semantic), `pg_partman` (Episodic partitioning)
- **State:** TanStack Query v5 (Optimistic UI), `pg_notify` (Real-time sync)
- **UI:** shadcn/ui + Tailwind + react-force-graph-3d (WebGL)

## V3.1 Ingestion Rules (NON-NEGOTIABLE)

### 1. Fractional Indexing
- **Fractional Indexing:** All ordering must use Base62 `rank_key`. Never use integers for sort order.
- **ALGORITHM:** `fi_generate_key_between(prev, next)` for O(1) insertions between any two items.
- **COLLISION PREVENTION:** Handle `UNIQUE(parent_id, rank_key)` constraint violations with retry logic.
- **INFINITE EXPANSION:** Keys must support unlimited insertions (e.g., 'a0' â†’ 'a0V') without rebalancing.

### 2. Optimistic UI
- **Optimistic UI:** UI must reflect changes immediately. Use `useMutation` with `queryClient.setQueryData` for all editor writes.
- **ZERO-LATENCY:** Debounced auto-save with immediate visual feedback during typing.
- **ROLLBACK:** Automatic rollback on sync failures with user notification.

### 3. Real-time Synchronization
- **Real-time Sync:** Rely on the `pg_notify` bridge in `src/lib/realtime` to sync the editor state with the 3D Graph.
- **EVENT DRIVEN:** All block changes trigger `pg_notify` for cross-component updates.
- **BIDIRECTIONAL:** Editor â†” Graph navigation with seamless portal switching.

### 4. Type Safety
- **Type Safety:** Every TipTap block type must have a corresponding Zod schema.
- **JSON VALIDATION:** TipTap content validated against strict schemas before database storage.
- **RUNTIME SAFETY:** No `any` types allowed in editor or block manipulation code.

### 5. RPC & Move Logic
- **RPC Logic:** Moving a document or merging entities MUST happen via `move_document_atomic` (PL/pgSQL) to maintain ltree integrity.
- **ATOMIC OPERATIONS:** Single-query updates using `subpath` and `nlevel` ensure parent_id and path consistency for all descendants.
- **CYCLE PREVENTION:** Database-level checks prevent moving a folder into its own subtree.

### 6. Resilience & Stress Testing
- **Stress Testing:** All core operations (insertions, moves, ordering) must be validated via `scripts/stress-test-concurrent.ts` and `scripts/stress-test-fractional.ts`.
- **CONCURRENCY:** Use `FOR UPDATE` locking in migrations to prevent race conditions during bulk structural changes.
- **DEFERRABILITY:** Foreign keys on logging/audit tables (like `async_processing_errors`) must be `DEFERRABLE` to avoid transaction blocking during bulk loads.

### 6. Critical Utilities
- **UUIDv7:** Always use `generateUUIDv7()` from `@/lib/utils` for primary keys. Never use `crypto.randomUUID()` or V4 for core entities.
- **Ltree Paths:** Use `uuidToLtreeLabel()` to strip hyphens from UUIDs before creating ltree paths. Maintain the `root.uuid.uuid` format.
- **Fractional Indexing:** Use `generateKeyBetween()` for all ordering logic. Ensure database columns use `COLLATE "C"`.
- **Kysely Queries:** Use typed query modules in `src/lib/db/queries/`. Rely on `SelectableTable`, `InsertableTable`, and `UpdateableTable` types.

## Coding Standards

### Database Interactions
- **Kysely First:** Prefer Kysely for high-performance SQL, `ltree` operations, and specialized indexes.
- **Type Generation:** Run `npm run db:generate` after schema changes to update `generated-types.ts`.
- **RPC Second:** Use PL/pgSQL RPCs for atomic cross-table operations or complex hierarchy logic (moves/merges).
- **Migrations:** SQL migrations must be idempotent. NO "magic" ORM migrations.
- **Locking:** Use `FOR UPDATE SKIP LOCKED` for task queue consumers to prevent contention.

### TypeScript / React
- **Strict Typing:** `zod` schemas for EVERY input/output. No `any`.
- **Optimistic UI:** Mutations must update UI immediately. Use `queryClient.setQueryData` for instant feedback.
- **Components:** Server Components for Data Fetching. Client Components for Interactivity.
- **Editor Integration:** TipTap blocks must integrate seamlessly with TanStack Query cache.

### Coding Standards
- **Functional:** Prefer functional components and patterns. Avoid classes.
- **Async:** Use async/await for all DB operations.
- **Types:** STRICT TypeScript. No `any`. Use `interface` over `type` for public APIs.
- **Server Actions:** Use standard `use server` directives. Implement `zod` validation for all inputs.

### Database Constraints
- **Ltree:** Labels must match regex `^[A-Za-z0-9_]+$`. Strip hyphens from UUIDs.
- **Collations:** Always use `COLLATE "C"` for `sort_order` columns.
- **IDs:** Use `uuidv7` for primary keys.

### Architecture & Performance
- **Atomic Design:** UI components must be small and isolated.
- **Component Pruning:** Keep components atomic. If a component exceeds 150 lines, extract a sub-component.
- **Optimistic First:** All mutations must update the UI state before the Supabase server response is confirmed. Use `useOptimistic` or `useMutation` with optimistic updates.

### Next.js 15 Sovereignty
- **Async Request APIs:** Always use Next.js 15 async APIs for `headers()`, `cookies()`, and dynamic `params`.

### Context Rot Prevention
- **Knowledge Persistence:** Reference `version_3.2.md` and project manifests every time a new feature is initiated to prevent context drift.

### "Reasoning" Output
- When asked to plan, output a structured "Chain of Thought" block before code.
- Validate assumptions (e.g., "Does this schema change break the IVM view?").

## Documentation Protocol

### Auto-Archive Logic
- **Source of Truth:** `PROJECT_STRUCTURE.md` is the **Map**â€”always represents current state, architecture, and high-dependency files.
- **Log Rotation:** When `project_log.md` exceeds **10KB**:
  1. Create `logs/archive/` directory if it doesn't exist
  2. Move the **oldest entries** (bottom half) to `logs/archive/project_log_YYYY-MM.md`
  3. Keep recent entries (top half) in `project_log.md`
  4. Add archive reference at bottom: `*Older entries: See logs/archive/project_log_YYYY-MM.md*`
- **Naming Convention:** Archive files use format `project_log_YYYY-MM.md` (e.g., `project_log_2026-01.md`)
- **Trigger:** AI should check file size before adding new entries and auto-archive if threshold exceeded
- **Preservation:** Never delete log entriesâ€”only relocate for performance