# V3.2 Blocks RLS & Zod Schemas Implementation Plan

## Overview
This plan outlines the implementation of two critical components for V3.2:
1. **Database RLS Policies** (`database/migrations/v3.2/003_blocks_rls.sql`) - Multi-tenant security for blocks_v3 table
2. **Zod Schemas** (`src/lib/schemas/block.schema.ts`) - Runtime validation for block types and operations

## Task 1: Blocks RLS Policies

### Context Analysis
- **Existing RLS**: There are already RLS policies for the `blocks` table in `src/lib/db/migrations/003_rls_policies.sql`
- **New Table**: The `blocks_v3` table (created in `001_blocks_schema.sql`) needs its own RLS policies
- **Key Differences**: 
  - `blocks_v3` has different schema: `workspace_id`, `user_id`, `parent_id`, `path` (ltree)
  - Existing policies use `document_id` → `get_document_workspace_id()` helper
  - New policies should use direct `workspace_id` column

### Technical Requirements
1. Enable RLS: `ALTER TABLE blocks_v3 ENABLE ROW LEVEL SECURITY;`
2. Create `is_workspace_member()` helper function (SECURITY DEFINER, SQL language)
3. Create SELECT, INSERT, UPDATE, DELETE policies
4. Create performance index: `idx_workspace_members_lookup`

### Implementation Plan

#### Step 1: Create Helper Function
```sql
CREATE OR REPLACE FUNCTION is_workspace_member(p_workspace_id UUID)
RETURNS BOOLEAN
SECURITY DEFINER
SET search_path = public
LANGUAGE sql
STABLE
AS $$
  SELECT EXISTS (
    SELECT 1 FROM workspace_members
    WHERE workspace_id = p_workspace_id
    AND user_id = auth.uid()
  );
$$;
```

#### Step 2: Enable RLS and Create Policies
```sql
-- Enable RLS
ALTER TABLE blocks_v3 ENABLE ROW LEVEL SECURITY;

-- SELECT Policy
CREATE POLICY blocks_select ON blocks_v3
  FOR SELECT USING (is_workspace_member(workspace_id));

-- INSERT Policy  
CREATE POLICY blocks_insert ON blocks_v3
  FOR INSERT WITH CHECK (
    is_workspace_member(workspace_id)
    AND user_id = auth.uid()
  );

-- UPDATE Policy
CREATE POLICY blocks_update ON blocks_v3
  FOR UPDATE USING (is_workspace_member(workspace_id))
  WITH CHECK (is_workspace_member(workspace_id));

-- DELETE Policy
CREATE POLICY blocks_delete ON blocks_v3
  FOR DELETE USING (is_workspace_member(workspace_id));
```

#### Step 3: Create Performance Index
```sql
CREATE INDEX IF NOT EXISTS idx_workspace_members_lookup 
  ON workspace_members(workspace_id, user_id);
```

### Verification Requirements
- Test SELECT/INSERT/UPDATE/DELETE as member vs non-member
- Ensure `is_workspace_member()` is SECURITY DEFINER to prevent RLS bypass
- Verify helper function uses STABLE volatility for query planner optimization

## Task 2: Zod Schemas for Block Types

### Context Analysis
- **Existing Schemas**: There are Zod schemas in action files (`block-actions.ts`, `document-actions.ts`, etc.)
- **New Location**: Need to create centralized schemas in `src/lib/schemas/`
- **Block Type Enum**: Must match PostgreSQL `block_type` ENUM exactly

### Technical Requirements
1. Create `BlockTypeEnum` matching PostgreSQL ENUM
2. Create `TipTapContentSchema` for flexible JSONB
3. Create `BlockBaseSchema` with all block fields
4. Create `BlockInsertSchema` (omit computed fields)
5. Create `BlockUpdateSchema` (partial, require ID)
6. Create `BlockReorderSchema` for drag-drop operations
7. Export all schemas and types
8. Add barrel export to `src/lib/schemas/index.ts`

### Implementation Plan

#### Step 1: Create Directory Structure
```
src/lib/schemas/
├── block.schema.ts    # Main block schemas
├── index.ts           # Barrel exports
└── (future: document.schema.ts, workspace.schema.ts, etc.)
```

#### Step 2: Implement Block Schemas
```typescript
import { z } from 'zod';

// 1. Block Type Enum (matches PostgreSQL ENUM)
export const BlockTypeEnum = z.enum([
  'page',
  'text', 
  'heading',
  'task',
  'code',
  'quote',
  'divider',
  'image',
  'table',
]);
export type BlockType = z.infer<typeof BlockTypeEnum>;

// 2. TipTap Content Schema
export const TipTapContentSchema = z.object({
  type: z.string(),
  content: z.array(z.any()).optional(),
  attrs: z.record(z.any()).optional(),
  marks: z.array(z.any()).optional(),
  text: z.string().optional(),
}).passthrough();

// 3. Block Base Schema
export const BlockBaseSchema = z.object({
  id: z.string().uuid(),
  workspace_id: z.string().uuid(),
  user_id: z.string().uuid(),
  parent_id: z.string().uuid().nullable(),
  type: BlockTypeEnum,
  content: TipTapContentSchema,
  sort_order: z.string().min(1),
  path: z.string().regex(/^[a-z0-9]+(\.[a-z0-9]+)*$/i, 'Invalid ltree path'),
  created_at: z.string().datetime(),
  updated_at: z.string().datetime(),
});
export type Block = z.infer<typeof BlockBaseSchema>;

// 4. Insert Schema
export const BlockInsertSchema = BlockBaseSchema.omit({
  path: true,
  created_at: true,
  updated_at: true,
}).extend({
  id: z.string().uuid().optional(),
});
export type BlockInsert = z.infer<typeof BlockInsertSchema>;

// 5. Update Schema
export const BlockUpdateSchema = BlockBaseSchema.partial().required({ id: true });
export type BlockUpdate = z.infer<typeof BlockUpdateSchema>;

// 6. Reorder Schema
export const BlockReorderSchema = z.object({
  block_id: z.string().uuid(),
  new_parent_id: z.string().uuid().nullable(),
  prev_sort_order: z.string().nullable(),
  next_sort_order: z.string().nullable(),
});
export type BlockReorder = z.infer<typeof BlockReorderSchema>;
```

#### Step 3: Create Barrel Export
```typescript
// src/lib/schemas/index.ts
export * from './block.schema';
```

### Verification Requirements
- All schemas exported from central file
- Types exported alongside schemas (`z.infer<typeof ...>`)
- `BlockTypeEnum` matches PostgreSQL ENUM exactly
- Path regex validates ltree format
- Insert schema omits database-computed fields

## Dependencies & Integration

### Task Dependencies
1. **RLS Task**: Depends on `001_blocks_schema.sql` (creates `blocks_v3` table)
2. **Schemas Task**: Independent, but should align with existing action schemas

### Integration Points
- **RLS**: Will integrate with existing authentication system (`auth.uid()`)
- **Schemas**: Will be used by:
  - Server Actions (`src/lib/actions/block-actions.ts`)
  - API endpoints
  - Frontend form validation

## Implementation Todo Lists

### Task 1: RLS Policies Todo List
```markdown
- [ ] Create migration file `database/migrations/v3.2/003_blocks_rls.sql`
- [ ] Implement `is_workspace_member()` helper function
- [ ] Enable RLS on `blocks_v3` table
- [ ] Create SELECT policy
- [ ] Create INSERT policy  
- [ ] Create UPDATE policy
- [ ] Create DELETE policy
- [ ] Create performance index
- [ ] Add verification comments
- [ ] Test with sample data
```

### Task 2: Zod Schemas Todo List
```markdown
- [ ] Create directory `src/lib/schemas/`
- [ ] Create `block.schema.ts` with all required schemas
- [ ] Create `index.ts` barrel export
- [ ] Update existing action files to use new schemas (optional)
- [ ] Add TypeScript tests for schema validation
- [ ] Verify enum matches PostgreSQL
```

## Risk Assessment

### Potential Issues
1. **RLS Performance**: The `is_workspace_member()` function must be efficient; ensure index exists
2. **Schema Compatibility**: New schemas must not break existing code
3. **Migration Order**: RLS migration must run after table creation but before data insertion

### Mitigation Strategies
1. Use `EXPLAIN ANALYZE` to verify query performance
2. Create backward-compatible schemas initially
3. Follow proper migration numbering sequence

## Next Steps
1. Switch to Code mode to implement both tasks
2. Create RLS migration file first (depends on existing table)
3. Create Zod schemas directory and files
4. Test both components with verification scripts